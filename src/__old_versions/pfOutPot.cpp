/*
 * @Author: chaomy
 * @Date:   2017-10-30 18:46:14
 * @Last Modified by:   chaomy
 * @Last Modified time: 2017-11-23 14:37:03
 */

#include "pfHome.h"

using std::cerr;
using std::cout;
using std::endl;
using std::fstream;
using std::to_string;

void pfHome::recordStage(int cnt) {
  string copy = sparams["tmpfile"];
  sparams["tmpfile"] = sparams["tmpdir"] + "/" + sparams["tmpfile"];
  sparams["tmpfile"] += ("." + to_string(cnt)); 
  writePot();
  sparams["tmpfile"] = copy;

  copy = sparams["lmpfile"];
  sparams["lmpfile"] = sparams["lmpdir"] + "/" + sparams["lmpfile"];
  sparams["lmpfile"] += ("." + to_string(cnt));  
  writeLMPS(ini);
  sparams["lmpfile"] = copy;
}

void pfHome::writePot(const vector<double>& vv) {
  FILE* fid = fopen(sparams["tmpfile"].c_str(), "w");
  if (!fid) cerr << "error opening " + sparams["tmpfile"] << endl;

  fprintf(fid, "#F 4 %d\n", nfuncs);
  fprintf(fid, "#T %s \n", sparams["ptype"].c_str());
  fprintf(fid, "#C %s \n", sparams["elem"].c_str());
  fprintf(fid, "## %s-%s %s %s\n", sparams["elem"].c_str(),
          sparams["elem"].c_str(), sparams["elem"].c_str(),
          sparams["elem"].c_str());

  if (sparams["ptype"] == "EAM")
    fprintf(fid, "#G 3 3 3\n");
  else if (sparams["ptype"] == "ADP")
    fprintf(fid, "#G 3 3 3 3 3\n");
  else if (sparams["ptype"] == "MEAM")
    fprintf(fid, "#G 3 3 3 3 3\n");
  fprintf(fid, "#E\n");

  for (int i = 0; i < nfuncs; i++) fprintf(fid, "%d\n", funcs[i].npts);
  fprintf(fid, "\n");

  for (int i = 0; i < nfuncs; i++) {
    int stpnt = startps[i];
    fprintf(fid, "%.16e %.16e\n", vv[stpnt + funcs[i].npts],
            vv[stpnt + funcs[i].npts + 1]);
    for (int j = 0; j < funcs[i].npts; j++)
      fprintf(fid, "%.16e %.16e\n", funcs[i].xx[j], vv[stpnt + j]);
    fprintf(fid, "\n");
  }
  fclose(fid);
}

void pfHome::writePot() {
  FILE* fid = fopen(sparams["tmpfile"].c_str(), "w");
  if (!fid) cerr << "error opening " + sparams["tmpfile"] << endl;

  fprintf(fid, "#F 4 %d\n", nfuncs);
  fprintf(fid, "#T %s \n", sparams["ptype"].c_str());
  fprintf(fid, "#C %s \n", sparams["elem"].c_str());
  fprintf(fid, "## %s-%s %s %s\n", sparams["elem"].c_str(),
          sparams["elem"].c_str(), sparams["elem"].c_str(),
          sparams["elem"].c_str());

  if (sparams["ptype"] == "EAM")
    fprintf(fid, "#G  3  3  3\n");
  else if (sparams["ptype"] == "ADP")
    fprintf(fid, "#G 3 3 3 3 3\n");
  else if (sparams["ptype"] == "MEAM")
    fprintf(fid, "#G 3 3 3 3 3\n");
  fprintf(fid, "#E\n");
  for (int i = 0; i < nfuncs; i++) fprintf(fid, "%d\n", funcs[i].npts);
  fprintf(fid, "\n");

  for (int i = 0; i < nfuncs; i++) {
    fprintf(fid, "%.16e %.16e\n", funcs[i].g1.front(), funcs[i].g1.back());
    for (int j = 0; j < funcs[i].npts; j++)
      fprintf(fid, "%.16e %.16e\n", funcs[i].xx[j], funcs[i].yy[j]);
    fprintf(fid, "\n");
  }
  fclose(fid);
}

void pfHome::writeMEAM() {
  FILE* fid = fopen(sparams["lmpfile"].c_str(), "w");
  if (!fid) cerr << "error opening " + sparams["lmpfile"] << endl;
  fprintf(fid, "#LAMMPS MEAM/spline (%.3f) generated by modified potfit\n",
          dparams["mass"]);
  for (int i = 0; i < nfuncs; i++) {
    fprintf(fid, "%d\n", funcs[i].npts);
    fprintf(fid, "%.12e %.12e\n", funcs[i].g1.front(), funcs[i].g1.back());
    fprintf(fid, "1 0 0 0 1\n");
    for (int j = 0; j < funcs[i].npts; j++)
      fprintf(fid, "%.12e %.12e %.12e\n", funcs[i].xx[j], funcs[i].yy[j],
              funcs[i].g2[j]);
  }
  fclose(fid);
}

void pfHome::writeLMPS(const vector<double>& vv) {
  int cnt = 0;
  for (int i = 0; i < nfuncs; i++) {
    for (int j = 0; j < funcs[i].npts; j++) funcs[i].yy[j] = vv[cnt++];
    funcs[i].g1.front() = vv[cnt++];
    funcs[i].g1.back() = vv[cnt++];
    spline(funcs[i], gradRight[i]);  // update splines
  }
  if (!sparams["ptype"].compare("MEAM"))
    writeMEAM();
  else
    writeLMPS();
}

void pfHome::writeLMPS() {
  FILE* fid = fopen(sparams["lmpfile"].c_str(), "w");
  if (!fid) cerr << "error opening " + sparams["lmpfile"] << endl;

  // header
  fprintf(fid, "%s %s \n", sparams["elem"].c_str(), sparams["ptype"].c_str());
  fprintf(fid, "Chaoming Yang \n");
  fprintf(fid, "(%s %s) \n", __DATE__, __TIME__);

  // n types
  fprintf(fid, "1 %s\n", sparams["elem"].c_str());
  /* line 5: Nrho, drho, Nr, dr, cutoff */
  double dr = funcs[PHI].xx.back() / (LMPPNTS - 1);
  double drho = funcs[EMF].xx.back() / (LMPPNTS - 1);

  fprintf(fid, "%d %lf %d %lf %lf\n", LMPPNTS, drho, LMPPNTS, dr,
          funcs[PHI].xx.back());
  fprintf(fid, "%d %lf 0\n", iparams["atomicNum"], dparams["mass"]);
  double val = 0.0;
  /* embedding function */
  double r = 0.0;
  for (int i = 0; i < LMPPNTS; i++, r += drho) {
    splint(funcs[EMF], r, val);
    fprintf(fid, "%.16e\n", val);
  }

  r = 0.0;
  /* transfer function rho(r) */
  for (int i = 0; i < LMPPNTS; i++, r += dr) {
    splint(funcs[RHO], r, val);
    fprintf(fid, "%.16e\n", val);
  }

  /* pair function phi(r) */
  r = 0.0;
  for (int i = 0; i < LMPPNTS; i++, r += dr) {
    splint(funcs[PHI], r, val);
    fprintf(fid, "%.16e\n", r * val);
  }

  if (sparams["ptype"] == "ADP") {
    /* dipole distortion u(r) */
    r = 0.0;
    for (int i = 0; i < LMPPNTS; i++, r += dr) {
      splint(funcs[ADPU], r, val);
      fprintf(fid, "%.16e\n", val);
    }

    /* quadrupole distortion */
    r = 0.0;
    for (int i = 0; i < LMPPNTS; i++, r += dr) {
      splint(funcs[ADPW], r, val);
      fprintf(fid, "%.16e\n", val);
    }
  }  // if ADP

  fclose(fid);
}